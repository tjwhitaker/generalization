///////////////////////////////////////////////////////////////////
// genNet.C
// Copyright (C) 2007  Faustino J. Gomez
//
// this file is automatically generated by create_net_types.pl
//
///////////////////////////////////////////////////////////////////
#include <iostream>
#include <string.h>
#include <typeinfo> 
using std::cout; 
using std::cerr; 
using std::endl;
#include "Networks.h" 
#include "genNet.h" 

char* getNetTypeName(Network *net)
{
  const char *tmp_id = typeid( *net ).name();
  static bool cache = false;
  static vector<const char*> names(8);

  if(!cache){
     Network *tmp;
     names[0] = typeid( *(tmp = new FeedForwardNetwork(0,0,0) )).name(); delete tmp;
     names[1] = typeid( *(tmp = new SimpleRecurrentNetwork(0,0,0) )).name(); delete tmp;
     names[2] = typeid( *(tmp = new SecondOrderRecurrentNetwork(0,0,0) )).name(); delete tmp;
     names[3] = typeid( *(tmp = new FullyRecurrentNetwork(0,0,0) )).name(); delete tmp;
     names[4] = typeid( *(tmp = new FullyRecurrentNetwork2(0,0,0) )).name(); delete tmp;
     names[5] = typeid( *(tmp = new LinearRecurrentNetwork(0,0,0) )).name(); delete tmp;
     names[6] = typeid( *(tmp = new SingleLayerFeedForwardNetwork(0,0,0) )).name(); delete tmp;
     names[7] = typeid( *(tmp = new LSTMNetwork(0,0,0) )).name(); delete tmp;
     cache = true; 
  } 

  if(!strcmp( names[0], tmp_id ) )
      { return "FeedForwardNetwork"; }
  else  if(!strcmp( names[1], tmp_id ) )
      { return "SimpleRecurrentNetwork"; }
  else  if(!strcmp( names[2], tmp_id ) )
      { return "SecondOrderRecurrentNetwork"; }
  else  if(!strcmp( names[3], tmp_id ) )
      { return "FullyRecurrentNetwork"; }
  else  if(!strcmp( names[4], tmp_id ) )
      { return "FullyRecurrentNetwork2"; }
  else  if(!strcmp( names[5], tmp_id ) )
      { return "LinearRecurrentNetwork"; }
  else  if(!strcmp( names[6], tmp_id ) )
      { return "SingleLayerFeedForwardNetwork"; }
  else  if(!strcmp( names[7], tmp_id ) )
      { return "LSTMNetwork"; }
}

Network* genNet(EspNetType type, int in, int hid, int out)
{
   switch ( type ){
     case 0: return new FeedForwardNetwork(in, hid, out); break;
     case 1: return new SimpleRecurrentNetwork(in, hid, out); break;
     case 2: return new SecondOrderRecurrentNetwork(in, hid, out); break;
     case 3: return new FullyRecurrentNetwork(in, hid, out); break;
     case 4: return new FullyRecurrentNetwork2(in, hid, out); break;
     case 5: return new LinearRecurrentNetwork(in, hid, out); break;
     case 6: return new SingleLayerFeedForwardNetwork(in, hid, out); break;
     case 7: return new LSTMNetwork(in, hid, out); break;
     default:
        cerr << "Error - network not of known type: "
       	     << type << endl;
       exit(1);
       break;
   }
}


Network* genNet(char *type, int in, int hid, int out)
{
   return genNet(netStrNameToEnum(type), in, hid, out); 
}
EspNetType netStrNameToEnum(char *type){
  if(!strcmp(type, "FeedForwardNetwork"))
     return TYPE_FeedForwardNetwork;
  else  if(!strcmp(type, "SimpleRecurrentNetwork"))
     return TYPE_SimpleRecurrentNetwork;
  else  if(!strcmp(type, "SecondOrderRecurrentNetwork"))
     return TYPE_SecondOrderRecurrentNetwork;
  else  if(!strcmp(type, "FullyRecurrentNetwork"))
     return TYPE_FullyRecurrentNetwork;
  else  if(!strcmp(type, "FullyRecurrentNetwork2"))
     return TYPE_FullyRecurrentNetwork2;
  else  if(!strcmp(type, "LinearRecurrentNetwork"))
     return TYPE_LinearRecurrentNetwork;
  else  if(!strcmp(type, "SingleLayerFeedForwardNetwork"))
     return TYPE_SingleLayerFeedForwardNetwork;
  else  if(!strcmp(type, "LSTMNetwork"))
     return TYPE_LSTMNetwork;
}

char*  netEnumToStrName(EspNetType type){
  switch (type) { 
     case 0: return "FeedForwardNetwork"; break;
     case 1: return "SimpleRecurrentNetwork"; break;
     case 2: return "SecondOrderRecurrentNetwork"; break;
     case 3: return "FullyRecurrentNetwork"; break;
     case 4: return "FullyRecurrentNetwork2"; break;
     case 5: return "LinearRecurrentNetwork"; break;
     case 6: return "SingleLayerFeedForwardNetwork"; break;
     case 7: return "LSTMNetwork"; break;
     default:
        cerr << "Error - network not of known type: "
       	     << type << endl;
       exit(1);
       break;
   }
}
EspNetType intToNetEnum(int type){
  switch (type) { 
     case 0: return TYPE_FeedForwardNetwork; break;
     case 1: return TYPE_SimpleRecurrentNetwork; break;
     case 2: return TYPE_SecondOrderRecurrentNetwork; break;
     case 3: return TYPE_FullyRecurrentNetwork; break;
     case 4: return TYPE_FullyRecurrentNetwork2; break;
     case 5: return TYPE_LinearRecurrentNetwork; break;
     case 6: return TYPE_SingleLayerFeedForwardNetwork; break;
     case 7: return TYPE_LSTMNetwork; break;
     default:
        cerr << "Error - network not of known type: "
       	     << type << endl;
       exit(1);
       break;
   }
}


void listNetTypes()
{
   cout << "Available network types:" << endl; 
   cout << "  0 : FeedForwardNetwork" << endl;
   cout << "  1 : SimpleRecurrentNetwork" << endl;
   cout << "  2 : SecondOrderRecurrentNetwork" << endl;
   cout << "  3 : FullyRecurrentNetwork" << endl;
   cout << "  4 : FullyRecurrentNetwork2" << endl;
   cout << "  5 : LinearRecurrentNetwork" << endl;
   cout << "  6 : SingleLayerFeedForwardNetwork" << endl;
   cout << "  7 : LSTMNetwork" << endl;
}
